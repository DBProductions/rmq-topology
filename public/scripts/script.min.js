(function () {
  'use strict';

  class Base {
    /**
     * Base class for other components.
     *
     * @param {number} x - x position
     * @param {number} y - y position
     */
    constructor(x, y) {
      this.x = x;
      this.y = y;
    }

    /**
     * Add object to scene.
     *
     * @param {Scene} scene - scene on canvas
     * @returns {object} this
     */
    addToScene(scene) {
      this.scene = scene;
      this.ctx = scene.ctx;
      scene.addActor(this);
      return this
    }

    /**
     * Generates an UUID.
     *
     * https://www.w3resource.com/javascript-exercises/fundamental/javascript-fundamental-exercise-253.php
     * @returns {string} - uuid
     */
    createUUID() {
      return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c) =>
        (
          c ^
          (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))
        ).toString(16)
      )
    }

    update(dt) {} // eslint-disable-line no-unused-vars
  }

  class BaseComponent extends Base {
    /**
     * Base component class for other components.
     *
     * @param {number} x - x position
     * @param {number} y - y position
     * @extends Base
     */
    constructor(x, y) {
      super(x, y);
      this.id = this.createUUID();
      this.x = x;
      this.y = y;
      this.dragged = false;
      this.hover = false;
      this.debug = false;
    }

    update(dt) {} // eslint-disable-line no-unused-vars
  }

  class BaseMessage extends Base {
    /**
     * Base message class for other messages.
     *
     * @param {number} x - x position
     * @param {number} y - y position
     * @param {integer} radius - radius of the circle
     * @param {string} fillStyle - hex color code to fill the circle
     * @extends Base
     */
    constructor(x, y, radius, fillStyle) {
      super(x, y);
      this.id = this.createUUID();
      this.x = x;
      this.y = y;
      this.radius = radius || 3;
      this.fillStyle = fillStyle || '#c82124';
      this.dist = null;
      this.rad = null;
      this.angle = null;
      this.thrust = 5;
    }

    render() {
      this.ctx.beginPath();
      this.ctx.fillStyle = this.fillStyle;
      this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
      this.ctx.fill();
    }
  }

  class ExchangeMessage extends BaseMessage {
    /**
     * Message object between producer and exchange.
     *
     * @param {number} x - x position of the message
     * @param {number} y - y position of the message
     * @param {Exchange} exchange - Exchange object
     * @param {string} routingKey - routing key of the message
     * @param {boolean} rejected - rejected message
     * @param {number} radius - radius of the circle
     * @param {string} fillColor - hex color code to fill the circle
     * @extends BaseMessage
     */
    constructor(x, y, exchange, routingKey, rejected, radius, fillColor) {
      super(x, y, radius, fillColor);
      this.exchange = exchange;
      this.rejected = rejected || false;
      this.targetX = this.exchange.x;
      this.targetY = this.exchange.y;
      this.routingKey = routingKey;
    }

    update() {
      this.dx = this.targetX - this.x;
      this.dy = this.targetY - this.y;
      this.dist = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
      this.rad = Math.atan2(this.dy, this.dx);
      this.angle = (this.rad / Math.PI) * 180;

      const velX = (this.dx / this.dist) * this.thrust;
      const velY = (this.dy / this.dist) * this.thrust;
      if (this.dist > 3) {
        this.x += velX;
        this.y += velY;
      } else {
        this.exchange.messageArrived(this);
      }
    }
  }

  class Producer extends BaseComponent {
    /**
     * Producer class represents a component that publish against exchanges.
     *
     * @param {number} x - x position of the producer
     * @param {number} y - y position of the producer
     * @param {string} name - optional identifier
     * @param {(object|Array)} publishes - list of exchanges to publish to
     * @param {string} routingKey - used routing key
     * @extends BaseComponent
     */
    constructor(x, y, name, publishes, routingKey) {
      super(x, y);
      this.name = name;
      this.width = 20;
      this.height = 20;
      this.lastSpawn = +new Date();
      this.curTime = 0;
      this.delayTime = 0;
      this.curDelay = 0;
      this.spawnTime = 1.0; // seconds
      this.fullSpawnTime = this.spawnTime;
      this.color = `#${Math.floor(Math.random() * 16777215).toString(16)}`;

      this.routingKey = routingKey || 'x.x.x';
      this.publishedMessages = 0;
      this.publishes = publishes;
      this.exchanges = [];
      this.debug = false;
    }

    /**
     * Adds the exchange to the list when not already present.
     *
     * @param {Exchange} exchange - Exchange object
     */
    addExchange(exchange) {
      const exchangeIndex = this.exchanges.findIndex((e) => e === exchange);
      if (exchangeIndex === -1) {
        this.exchanges.push(exchange);
      }
    }

    /**
     * Removes the exchange from the list.
     *
     * @param {Exchange} exchange - Exchange object
     */
    removeExchange(exchange) {
      const exchangeIndex = this.exchanges.findIndex((e) => e === exchange);
      if (exchangeIndex !== -1) {
        if (this.exchanges.length === 1) {
          this.exchanges = [];
        } else {
          this.exchanges.splice(exchangeIndex, 1);
        }
      }
    }

    /**
     * Determines at which time a new message should be created and be published.
     *
     * @param {number} dt - delta time from the timer
     */
    update(dt) {
      this.spawnTime -= dt;
      if (this.spawnTime < 0) {
        this.exchanges.forEach((val) => {
          new ExchangeMessage(
            this.x + this.width / 2,
            this.y + this.height / 2,
            val,
            this.routingKey,
            undefined,
            undefined,
            this.color
          ).addToScene(this.scene);
          this.publishedMessages += 1;
        });
        this.spawnTime = this.fullSpawnTime;
      }
    }

    /**
     * Render the producer and lines to every exchange from the list.
     *
     */
    render() {
      this.ctx.setLineDash([]);
      // shadow
      this.ctx.globalAlpha = 0.4;
      this.ctx.beginPath();
      this.ctx.fillStyle = '#000';
      this.ctx.rect(this.x + 2, this.y + 2, this.width, this.height);
      this.ctx.fill();

      this.ctx.globalAlpha = 1.0;
      this.ctx.beginPath();
      this.ctx.strokeStyle = '#000';
      this.ctx.lineWidth = 1;
      if (this.hover) {
        this.ctx.lineWidth = 2;
      }
      this.ctx.rect(this.x, this.y, this.width, this.height);
      this.ctx.stroke();

      if (this.dragged) {
        this.ctx.fillStyle = '#ccc';
        this.ctx.fill();
      } else {
        this.ctx.fillStyle = '#fff';
        this.ctx.fill();
      }

      this.ctx.font = '10px Arial';
      this.ctx.fillStyle = '#000';
      this.ctx.fillText(
        this.name,
        this.x - this.name.length,
        this.y + this.height + 10
      );
      this.ctx.fillText(
        `Send: ${this.publishedMessages}`,
        this.x - `Send: ${this.publishedMessages}`.length,
        this.y + this.height + 20
      );
      this.ctx.fillText(
        this.routingKey,
        this.x - this.routingKey.length,
        this.y + this.height + 30
      );

      this.exchanges.forEach((val) => {
        this.ctx.beginPath();
        this.ctx.strokeStyle = '#aaa';
        this.ctx.setLineDash([3, 3]);
        this.ctx.lineWidth = 1;
        this.ctx.moveTo(this.x + this.width / 2, this.y + this.height / 2);
        this.ctx.lineTo(val.x, val.y);
        this.ctx.stroke();
      });
    }
  }

  class RejectMessage extends BaseMessage {
    /**
     * Message object when a message gets rejected from consumer.
     *
     * @param {number} x - x position of the message
     * @param {number} y - y position of the message
     * @param {Queue} queue - Queue object
     * @extends BaseMessage
     */
    constructor(x, y, queue) {
      super(x, y);
      this.queue = queue;
      this.rejected = true;
      if (this.queue) {
        this.targetX = this.queue.x;
        this.targetY = this.queue.y;
      }
    }

    update() {
      if (this.queue) {
        this.dx = this.targetX - this.x;
        this.dy = this.targetY - this.y;
        this.dist = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
        this.rad = Math.atan2(this.dy, this.dx);
        this.angle = (this.rad / Math.PI) * 180;

        const velX = (this.dx / this.dist) * this.thrust;
        const velY = (this.dy / this.dist) * this.thrust;
        if (this.dist > 3) {
          this.x += velX;
          this.y += velY;
        } else {
          this.queue.messageArrived(this);
        }
      }
    }
  }

  class Consumer extends BaseComponent {
    /**
     * Consumer class represents a component which consumes messages from a queue.
     *
     * @param {number} x - x position of the consumer
     * @param {number} y - y position of the consumer
     * @param {string} name - optional identifier
     * @param {*} consumes
     * @param {string} mode - ack or reject
     * @extends BaseComponent
     */
    constructor(x, y, name, consumes, mode) {
      super(x, y);
      this.name = name;
      this.mode = mode || 'ack';
      this.arrivedMessages = 0;
      this.width = 30;
      this.height = 30;
      this.consumes = consumes;
      this.queues = [];
    }

    /**
     * Adds a queue to the list.
     *
     * @param {Queue} queue - Queue object
     */
    addQueue(queue) {
      const queueIndex = this.queues.findIndex((e) => e === queue);
      if (queueIndex === -1) {
        queue.addConsumer(this);
        this.queues.push(queue);
      }
    }

    /**
     * Removes a queue from the list or empty the list.
     *
     * @param {Queue} queue - Queue object
     */
    removeQueue(queue) {
      const queueIndex = this.queues.findIndex((e) => e === queue);
      if (queueIndex !== -1) {
        if (this.queues.length === 1) {
          this.queues = [];
        } else {
          this.queues.splice(queueIndex, 1);
        }
      }
    }

    /**
     * Handler for arriving messages. Checks the mode and reject or count the arrived messages.
     *
     * @param {QueueMessage} msg - message object
     */
    messageArrived(msg) {
      if (this.mode === 'reject') {
        new RejectMessage(
          this.x + this.width / 2,
          this.y + this.height / 2,
          msg.queue
        ).addToScene(this.scene);
      } else {
        this.arrivedMessages += 1;
      }
      this.scene.removeActor(msg);
    }

    render() {
      this.ctx.setLineDash([]);
      // shadow
      this.ctx.globalAlpha = 0.4;
      this.ctx.beginPath();
      this.ctx.fillStyle = '#000';
      this.ctx.rect(this.x + 2, this.y + 2, this.width, this.height);
      this.ctx.fill();

      this.ctx.globalAlpha = 1.0;
      this.ctx.beginPath();
      this.ctx.strokeStyle = '#000';
      this.ctx.lineWidth = 1;
      if (this.hover) {
        this.ctx.lineWidth = 2;
      }
      this.ctx.rect(this.x, this.y, this.width, this.height);
      this.ctx.stroke();

      if (this.dragged) {
        this.ctx.fillStyle = '#ccc';
        this.ctx.fill();
      } else {
        this.ctx.fillStyle = '#fff';
        this.ctx.fill();
      }

      this.ctx.font = '10px Arial';
      this.ctx.fillStyle = '#000';
      this.ctx.fillText(
        `${this.name} (${this.mode})`,
        this.x - `${this.name} (${this.mode})`.length,
        this.y + this.height + 10
      );
      this.ctx.fillText(
        `${this.arrivedMessages} msgs arrived`,
        this.x - `${this.arrivedMessages} msgs arrived`.length,
        this.y + this.height + 20
      );

      this.queues.forEach((val) => {
        this.ctx.beginPath();
        this.ctx.strokeStyle = '#aaa';
        this.ctx.setLineDash([4, 4]);
        this.ctx.lineWidth = 1;
        this.ctx.moveTo(this.x + this.width / 2, this.y + this.height / 2);
        this.ctx.lineTo(val.x, val.y);
        this.ctx.stroke();
      });
    }
  }

  class BindingMessage extends BaseMessage {
    /**
     * Message object between exchange and queue.
     *
     * @param {number} x - x position of the message
     * @param {number} y - y position of the message
     * @param {Binding} binding - Binding object
     * @param {string} fillColor - hex color code to fill the circle
     * @extends BaseMessage
     */
    constructor(x, y, binding, fillColor) {
      super(x, y, 5, fillColor);
      this.binding = binding;
      this.targetX = this.binding.destination.x;
      this.targetY = this.binding.destination.y;
    }

    update() {
      this.dx = this.targetX - this.x;
      this.dy = this.targetY - this.y;
      this.dist = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
      this.rad = Math.atan2(this.dy, this.dx);
      this.angle = (this.rad / Math.PI) * 180;

      if (this.dist > 3) {
        this.x += (this.dx / this.dist) * this.thrust;
        this.y += (this.dy / this.dist) * this.thrust;
      } else {
        this.binding.destination.messageArrived(this);
      }
    }
  }

  class Exchange extends BaseComponent {
    /**
     * Exchange class represents a component which receives messages and route them to queues.
     *
     * @param {number} x - x position of the exchange
     * @param {number} y - y position of the exchange
     * @param {string} name - identifier
     * @param {string} type - exchange type
     * @extends BaseComponent
     */
    constructor(x, y, name, type) {
      super(x, y);
      this.name = name;
      this.type = type || 'direct';
      this.radius = 15;
      // this.binding = null;
      this.bindings = [];
    }

    /**
     * Removes a binding from the exchange.
     *
     * @param {Binding} binding - Binding object
     */
    removeBinding(binding) {
      const bindingIndex = this.bindings.findIndex((c) => c === binding);
      if (bindingIndex !== -1) {
        if (this.bindings.length === 1) {
          this.bindings = [];
        } else {
          this.bindings.splice(bindingIndex, 1);
        }
      }
    }

    /**
     * Handler for arriving messages.
     *
     * @param {ExchangeMessage} msg
     */
    messageArrived(msg) {
      const { routingKey, fillStyle } = msg;
      let count = false;
      let sendMsg = false;
      this.bindings.forEach((val) => {
        if (this.type === 'topic') {
          // TODO: more specific to handle * or #
          if (val.routingKey === routingKey || val.routingKey === '#') {
            new BindingMessage(this.x, this.y, val, fillStyle).addToScene(
              this.scene
            );
            sendMsg = true;
          }
        } else if (this.type === 'direct') {
          if (val.destination.name === routingKey) {
            new BindingMessage(this.x, this.y, val, fillStyle).addToScene(
              this.scene
            );
            sendMsg = true;
          }
          // fanout
        } else {
          new BindingMessage(this.x, this.y, val, fillStyle).addToScene(
            this.scene
          );
          sendMsg = true;
        }
      });
      // no bindings, message is lost
      if (this.bindings.length === 0) {
        this.scene.lostMessages += 1;
        count = true;
      }
      // message not send, then it's lost
      if (!sendMsg && !count) {
        this.scene.lostMessages += 1;
      }
      this.scene.removeActor(msg);
    }

    render() {
      // shadow
      this.ctx.globalAlpha = 0.4;
      this.ctx.beginPath();
      this.ctx.fillStyle = '#000';
      this.ctx.arc(this.x + 2, this.y + 2, this.radius, 0, 2 * Math.PI);
      this.ctx.fill();

      this.ctx.globalAlpha = 1.0;
      this.ctx.beginPath();
      // this.ctx.fillStyle = gradient;
      this.ctx.fillStyle = '#ccc';
      this.ctx.setLineDash([]);
      this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
      this.ctx.fill();

      if (this.dragged) {
        this.ctx.stroke();
      }

      if (this.hover) {
        this.ctx.stroke();
      }

      this.ctx.font = '10px Arial';
      this.ctx.fillStyle = '#000';
      this.ctx.fillText(
        this.name,
        this.x - this.radius,
        this.y + this.radius + 10
      );
      this.ctx.fillText(
        this.type,
        this.x - this.radius,
        this.y + this.radius + 22
      );
    }
  }

  class QueueMessage extends BaseMessage {
    /**
     * Message object between queue and consumer.
     *
     * @param {number} x - x position of the message
     * @param {number} y - y position of the message
     * @param {Queue} queue - Queue object
     * @param {Consumer} consumer - Consumer object
     * @param {string} fillStyle
     * @extends BaseMessage
     */
    constructor(x, y, queue, consumer, fillStyle) {
      super(x, y, 3, fillStyle);
      this.queue = queue;
      this.consumer = consumer;
      if (this.consumer) {
        this.targetX = this.consumer.x + this.consumer.width / 2;
        this.targetY = this.consumer.y + this.consumer.height / 2;
      }
    }

    /**
     * Sets the consumer with coordinates.
     *
     * @param {Consumer} consumer - Consumer object
     */
    setConsumer(consumer) {
      this.consumer = consumer;
      this.targetX = this.consumer.x + this.consumer.width / 2;
      this.targetY = this.consumer.y + this.consumer.height / 2;
    }

    update() {
      if (this.consumer) {
        this.dx = this.targetX - this.x;
        this.dy = this.targetY - this.y;
        this.dist = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
        this.rad = Math.atan2(this.dy, this.dx);
        this.angle = (this.rad / Math.PI) * 180;

        const velX = (this.dx / this.dist) * this.thrust;
        const velY = (this.dy / this.dist) * this.thrust;
        if (this.dist > 3) {
          this.x += velX;
          this.y += velY;
        } else {
          this.consumer.messageArrived(this);
        }
      }
    }
  }

  class Queue extends BaseComponent {
    /**
     * Queue class represents a component which keeps the messages until they are consumed.
     *
     * @param {number} x - x position of the queue
     * @param {number} y - y position of the queue
     * @param {string} name - optional identifier
     * @param {number} ttl - `x-message-ttl` Argument of the queue
     * @param {Exchange} dlx - Exchange object as `x-dead-letter-exchange` argument
     * @param {number} maxLength - `x-max-length` argument of the queue
     * @extends BaseComponent
     */
    constructor(x, y, name, ttl, dlx, dlxrk, maxLength) {
      super(x, y);
      this.name = name;
      this.msgTtl = ttl || '';
      this.dlx = dlx;
      this.dlxrk = dlxrk || '';
      this.maxLength = maxLength || '';
      this.radius = 20;
      this.binding = null;
      this.bindings = [];
      this.consumers = [];
      this.messages = [];
    }

    /**
     * Adds a consumer to the queue.
     *
     * @param {Consumer} consumer - Consumer object
     */
    addConsumer(consumer) {
      if (this.consumers.findIndex((c) => c === consumer) === -1) {
        this.consumers.push(consumer);
      }
      // consumer added and messages present in queue
      if (this.consumers.length > 0 && this.messages.length > 0) {
        this.messages.forEach((val) => {
          val.msg.setConsumer(this.consumers[0]);
        });
        this.messages = [];
      }
    }

    /**
     * Removes a consumer from the queue.
     *
     * @param {Consumer} consumer - Consumer object
     */
    removeConsumer(consumer) {
      const consumerIndex = this.consumers.findIndex((c) => c === consumer);
      if (consumerIndex !== -1) {
        if (this.consumers.length === 1) {
          this.consumers = [];
        } else {
          this.consumers.splice(consumerIndex, 1);
        }
      }
    }

    /**
     * Handler for arriving messages.
     *
     * @param {QueueMessage} msg - QueueMessage object
     */
    messageArrived(msg) {
      const { fillStyle } = msg;
      if (msg.constructor.name === 'RejectMessage') {
        if (this.dlx) {
          new ExchangeMessage(
            this.x,
            this.y,
            this.dlx,
            this.dlxrk,
            true,
            undefined,
            fillStyle
          ).addToScene(this.scene);
        } else {
          this.scene.lostMessages += 1;
        }
      } else {
        // no consumer
        if (this.consumers.length === 0) {
          this.messages.push({
            ts: Date.now(),
            msg: new QueueMessage(
              this.x,
              this.y,
              this,
              null,
              fillStyle
            ).addToScene(this.scene)
          });
        } else {
          // deliver message random to one of the consumer
          new QueueMessage(
            this.x,
            this.y,
            this,
            this.consumers[Math.floor(Math.random() * this.consumers.length)],
            fillStyle
          ).addToScene(this.scene);
        }
        // max-length
        if (this.maxLength !== '' && this.maxLength < this.messages.length) {
          this.messages.pop();
          if (this.dlx) {
            new ExchangeMessage(
              this.x,
              this.y,
              this.dlx,
              this.dlxrk,
              fillStyle
            ).addToScene(this.scene);
          }
        }
      }
      this.scene.removeActor(msg);
    }

    update() {
      if (this.msgTtl > 0) {
        const now = Date.now();
        const msgToRemove = [];
        this.messages.forEach((val, i) => {
          if (now - val.ts >= this.msgTtl) {
            msgToRemove.push(i);
          }
        });
        msgToRemove.forEach((val) => {
          if (this.dlx) {
            new ExchangeMessage(this.x, this.y, this.dlx, this.dlxrk).addToScene(
              this.scene
            );
          } else {
            this.scene.lostMessages += 1;
          }
          this.messages.splice(val, 1);
        });
      }
    }

    render() {
      // shadow
      this.ctx.globalAlpha = 0.4;
      this.ctx.beginPath();
      this.ctx.fillStyle = '#000';
      this.ctx.arc(this.x + 2, this.y + 2, this.radius, 0, 2 * Math.PI);
      this.ctx.fill();

      this.ctx.globalAlpha = 1.0;
      this.ctx.beginPath();
      // this.ctx.fillStyle = gradient;
      this.ctx.fillStyle = '#ccc';
      this.ctx.setLineDash([]);
      this.ctx.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);
      this.ctx.fill();

      if (this.dragged) {
        this.ctx.stroke();
      }

      if (this.hover) {
        this.ctx.stroke();
      }

      if (this.dlx) {
        this.ctx.beginPath();
        this.ctx.strokeStyle = '#000';
        this.ctx.setLineDash([3, 3]);
        this.ctx.lineWidth = 1;
        this.ctx.moveTo(this.x, this.y);
        this.ctx.lineTo(this.dlx.x, this.dlx.y);
        this.ctx.stroke();
      }

      this.ctx.font = '10px Arial';
      this.ctx.fillStyle = '#000';
      this.ctx.fillText(
        this.name,
        this.x - this.radius,
        this.y + this.radius + 10
      );
      this.ctx.fillText(
        `${this.messages.length} msgs`,
        this.x - `${this.messages.length} msgs`.length,
        this.y + this.radius + 20
      );
    }
  }

  class Binding extends BaseComponent {
    /**
     * Binging class represents the binding between an exchange and a queue.
     *
     * @param {object} source
     * @param {object} destination
     * @param {string} routingKey - used routing key
     * @extends BaseComponent
     */
    constructor(source, destination, routingKey) {
      super(0, 0);
      this.source = source;
      this.destination = destination;
      this.routingKey = routingKey;
      // eslint-disable-next-line no-param-reassign
      source.binding = this;
      // eslint-disable-next-line no-param-reassign
      destination.binding = this;
      source.bindings.push(this);
      destination.bindings.push(this);
      this.setCoords();
    }

    /**
     * Sets x and y for the source and destination property.
     */
    setCoords() {
      this.x1 = this.source.x;
      this.x2 = this.destination.x;
      this.y1 = this.source.y;
      this.y2 = this.destination.y;
    }

    /**
     * http://phrogz.net/tmp/canvas_rotated_text.html
     *
     * @param {string} text - text to draw as label
     */
    drawLabel(text) {
      const alignment = 'center';
      const dx = this.x2 - this.x1;
      const dy = this.y2 - this.y1;
      const p = { x: this.x1, y: this.y1 };
      const pad = 1 / 2;

      this.ctx.save();
      this.ctx.textAlign = alignment;
      this.ctx.translate(p.x + dx * pad, p.y + dy * pad);
      this.ctx.rotate(Math.atan2(dy, dx + 3));
      this.ctx.fillText(text, 0, 0);
      this.ctx.restore();
    }

    update() {
      this.setCoords();
      this.dx = this.x2 - this.x1;
      this.dy = this.y2 - this.y1;
    }

    render() {
      this.ctx.beginPath();
      this.ctx.strokeStyle = '#000';
      this.ctx.setLineDash([]);
      this.ctx.lineWidth = 1;
      if (this.hover) {
        this.ctx.lineWidth = 2;
      }
      this.ctx.moveTo(this.x1, this.y1);
      this.ctx.lineTo(this.x2, this.y2);
      this.ctx.stroke();

      this.drawLabel(this.routingKey);
    }
  }

  class Scene {
    /**
     * The scene includes the actors and call their update and render methods.
     *
     * @param {*} ctx - context of the canvas
     * @param {number} width - width of the canvas
     * @param {number} height - height of the canvas
     */
    constructor(ctx, width, height) {
      this.ctx = ctx;
      this.width = width;
      this.height = height;
      this.curleft = 0;
      this.curtop = 0;
      const off = this.DOMOffset(ctx.canvas)
      ;[this.x, this.y] = [off[0], off[1]];
      this.actors = [];
      this.lostMessages = 0;
      this.description = '';
    }

    /**
     * Get DOM offset from given element.
     *
     * @param {Object} el - HTML DOM element
     * @returns {object} - x and y position
     */
    DOMOffset(el) {
      let ele = el;
      if (ele.offsetParent) {
        do {
          this.curleft += ele.offsetLeft;
          this.curtop += ele.offsetTop;
        } while ((ele = ele.offsetParent)) // eslint-disable-line no-cond-assign
      }
      return { x: this.curleft, y: this.curtop }
    }

    /**
     * Add an actor to the scene.
     *
     * @param {Object} actor
     */
    addActor(actor) {
      this.actors.push(actor);
    }

    /**
     * Remove an actor from the scene.
     *
     * @param {Object} actor
     */
    removeActor(actor) {
      this.actors.splice(
        this.actors.findIndex((o) => o === actor),
        1
      );
    }

    /**
     * Get object to id from scene.
     *
     * @param {string} id
     */
    getIdInScene(id) {
      let actor = null;
      this.actors.forEach((val) => {
        if (val.id === id) {
          actor = val;
        }
      });
      return actor
    }

    /**
     * Get objects based on the obj constructor.
     *
     * @param {string} obj
     */
    getObjectsInScene(obj) {
      const objs = [];
      this.actors.forEach((val) => {
        if (val.constructor.name === obj) {
          objs.push(val);
        }
      });
      return objs
    }

    /**
     * Empty the scene with setting and empty list as actors.
     *
     */
    purge() {
      this.actors = [];
    }

    /**
     * Iterates over the actors and call their update method.
     *
     * @param {number} dt
     */
    update(dt) {
      for (let i = 0; i < this.actors.length; i += 1) {
        this.actors[i].update(dt);
      }
    }

    /**
     * It renders first the binding and then the rest for a better visual effect.
     *
     * @param {number} dt
     */
    render(dt) {
      this.ctx.clearRect(0, 0, this.width, this.height);

      if (this.actors.length > 0) {
        this.ctx.font = '10px Arial';
        this.ctx.fillStyle = '#000';
        this.ctx.fillText(`${this.lostMessages} messages lost`, 50, 20);
      }
      this.ctx.font = '12px Arial';
      this.ctx.fillText(this.description, 50, this.height - 20);

      const allBindings = [];
      const noneBindings = [];
      const myFilter = (s) => s.constructor.name === 'Binding';
      this.actors.forEach((e, idx, arr) =>
        (myFilter(e) ? allBindings : noneBindings).push(e)
      );
      allBindings.forEach((val) => {
        val.render(dt);
      });
      noneBindings.forEach((val) => {
        val.render(dt);
      });
    }

    /**
     * It renders first the binding and then the rest for a better visual effect.
     *
     * @param {number} dt
     */
    renderOnce(dt) {
      this.ctx.clearRect(0, 0, this.width, this.height);

      if (this.actors.length > 0) {
        this.ctx.font = '10px Arial';
        this.ctx.fillStyle = '#000';
        this.ctx.fillText(`${this.lostMessages} messages lost`, 50, 20);
      }
      this.ctx.font = '12px Arial';
      this.ctx.fillText(this.description, 50, this.height - 20);

      const allBindings = [];
      const noneBindings = [];
      const myFilter = (s) => s.constructor.name === 'Binding';
      this.actors.forEach((e, idx, arr) =>
        (myFilter(e) ? allBindings : noneBindings).push(e)
      );
      allBindings.forEach((val) => {
        val.render(dt);
      });
      noneBindings.forEach((val) => {
        val.render(dt);
      });
    }
  }

  class Timer {
    /**
     * Timer for a specific target to call update and render methods on every tick.
     *
     * @param {object} target
     */
    constructor(target) {
      this.running = false;
      this.target = target;
    }

    /**
     * Start the timer.
     */
    start() {
      this.running = true;
      this.prevTime = +new Date() / 1000;
      this.tick();
    }

    /**
     * Stop the timer.
     */
    stop() {
      if (this.running) {
        this.running = false;
      }
    }

    /**
     * Tick of the timer.
     */
    tick() {
      const self = this;
      self.tick = () => {
        if (self.running) {
          const curTime = +new Date() / 1000;
          const dt = curTime - self.prevTime;
          self.time += dt;
          self.prevTime = curTime;
          self.target.update(dt);
          self.target.render(dt);
          window.requestAnimationFrame(self.tick);
        }
      };
      self.tick();
    }
  }

  /**
   * Calculates the point on the line that's nearest to the mouse position.
   *
   * https://stackoverflow.com/questions/24043967/detect-if-mouse-is-over-an-object-inside-canvas
   * @param {object} line - line with start and end point (x1,y1,x2,y2)
   * @param {number} x - x position
   * @param {number} y - y position
   * @returns {object}
   */
  const linepointNearestMouse = (line, x, y) => {
    const lerp = (a, b, c) => a + c * (b - a);
    const dx = line.x1 - line.x0;
    const dy = line.y1 - line.y0;
    const t = ((x - line.x0) * dx + (y - line.y0) * dy) / (dx * dx + dy * dy);
    const lineX = lerp(line.x0, line.x1, t);
    const lineY = lerp(line.y0, line.y1, t);
    return {
      x: lineX,
      y: lineY
    }
  };

  /**
   * Creates the topology shown on the canvas.
   * A new scene with timer plus the parts defined in the configuration.
   *
   * @param {object} ctx - canvas context
   * @param {object} conf - configuration as JSON
   */
  const createTopology = (ctx, conf) => {
    window.scene = new Scene(ctx, window.innerWidth, 450);
    if (conf.description) {
      window.scene.description = conf.description;
    }
    window.timer = new Timer(window.scene);

    const exchanges = [];
    const queues = [];

    if (conf.exchanges) {
      conf.exchanges.forEach((exchange) => {
        const newExchange = new Exchange(
          exchange.x,
          exchange.y,
          exchange.name,
          exchange.type
        );
        newExchange.addToScene(window.scene);
        exchanges.push(newExchange);
      });
    }
    if (conf.queues) {
      conf.queues.forEach((queue) => {
        const newQueue = new Queue(
          queue.x,
          queue.y,
          queue.name,
          queue.ttl,
          exchanges[queue.dlx],
          queue.dlxrk,
          queue.maxLength
        );
        newQueue.addToScene(window.scene);
        queues.push(newQueue);
      });
    }
    if (conf.producers) {
      conf.producers.forEach((producer) => {
        const newProducer = new Producer(
          producer.x,
          producer.y,
          producer.name,
          producer.publishes,
          producer.routingKey
        );
        producer.publishes.forEach((val) => {
          newProducer.addExchange(exchanges[val]);
        });
        newProducer.addToScene(window.scene);
      });
    }
    if (conf.consumers) {
      conf.consumers.forEach((consumer) => {
        const newConsumer = new Consumer(
          consumer.x,
          consumer.y,
          consumer.name,
          consumer.consumes,
          consumer.mode
        );
        consumer.consumes.forEach((val) => {
          newConsumer.addQueue(queues[val]);
        });
        newConsumer.addToScene(window.scene);
      });
    }
    if (conf.bindings) {
      conf.bindings.forEach((binding) => {
        const newBinding = new Binding(
          exchanges[binding.exchange],
          queues[binding.queue],
          binding.routingKey
        );
        newBinding.addToScene(window.scene);
      });
    }

    window.scene.renderOnce();
  };

  /**
   * Adds the CSS class to the selected one and remove it from all other ones.
   *
   * @param {string} form
   */
  const displayForm = (form) => {
    const formsCollection = document.getElementsByTagName('form');
    for (let i = 0; i < formsCollection.length; i += 1) {
      document
        .querySelector(`#${formsCollection[i].id}`)
        .parentNode.parentNode.classList.remove('panel-wrap-out');
      if (`${form.toLowerCase()}Form` === formsCollection[i].id) {
        document
          .querySelector(`#${formsCollection[i].id}`)
          .parentNode.parentNode.classList.add('panel-wrap-out');
      }
    }
  };

  /**
   * Gets the settings from loacalStorage and parse it as JSON.
   *
   * @returns {object} settings - settings as JSON from localStorage.
   */
  const getSettings = () => {
    const data = localStorage.getItem('rmqSettings');
    return JSON.parse(data)
  };

  /**
   * Sets the current settings in localStorage.
   *
   * @param {object} settings - settings as JSON to set in localStorage.
   */
  const setSettings = (settings) => {
    localStorage.setItem('rmqSettings', JSON.stringify(settings));
  };

  /**
   * Hide and show tab links and the content for it.
   *
   * @param {Object} Event
   */
  const changeSettingsTab = (e) => {
    e.preventDefault();
    try {
      const link = document.querySelector(`#settingsTabHref${e.target.innerHTML}`);
      if (link) {
        const tabLinks = document.querySelector('#settingsTabs');
        const liList = tabLinks.getElementsByTagName('li');
        for (let i in liList) {
          if (liList[i].classList) {
            liList[i].classList.remove('selected');
          }
        }

        const tabContent = document.querySelectorAll('#tabContainer > div');
        for (let d in tabContent) {
          if (tabContent[d].classList) {
            tabContent[d].classList.add('tab-hidden');
          }
        }

        link.classList.add('selected');
        document
          .querySelector(`#settingsTab${e.target.innerHTML}`)
          .classList.remove('tab-hidden');
      }
    } catch (err) {
      return
    }
  };

  /**
   * Display the form to edit settings.
   *
   * @param {Binding} binding - Binding object
   */
  const displaySettings = () => {
    document.querySelector('#settingsPanel').classList.add('panel-wrap-out');
    document.querySelector('#settingsErr').innerHTML = '';
    const settings = getSettings();
    if (settings) {
      document.querySelector('#settingsHost').value = settings.host;
      document.querySelector('#settingsPort').value = settings.port;
      document.querySelector('#settingsManagement').value = settings.management;
      document.querySelector('#settingsVHost').value = settings.vhost;
      document.querySelector('#settingsUsername').value = settings.username;
      document.querySelector('#settingsPassword').value = settings.password;
      document.querySelector('#settingsAsyncApiTitle').value =
        settings.asyncapi.title;
      document.querySelector('#settingsAsyncApiDescription').value =
        settings.asyncapi.description;
    }
  };

  /**
   * Sends the form to set settings.
   *
   * @param {object} e - Event object
   */
  const sendSettingsForm = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const host = document.querySelector('#settingsHost').value;
    let error = false;
    if (host === '') {
      error = 'Host is required.';
      document.querySelector('#settingsErr').innerHTML = error;
    } else {
      setSettings({
        host,
        port: document.querySelector('#settingsPort').value,
        management: document.querySelector('#settingsManagement').value,
        vhost: document.querySelector('#settingsVHost').value,
        username: document.querySelector('#settingsUsername').value,
        password: document.querySelector('#settingsPassword').value,
        asyncapi: {
          title: document.querySelector('#settingsAsyncApiTitle').value,
          description: document.querySelector('#settingsAsyncApiDescription')
            .value
        }
      });
      hideSettings(e);
    }
  };

  /**
   * Reset form values and remove CSS class from the settings panel.
   *
   * @param {object} e - Event object
   */
  const hideSettings = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const settingsParams = [
      '#settingsHost',
      '#settingsPort',
      '#settingsManagement',
      '#settingsVHost',
      '#settingsUsername',
      '#settingsPassword',
      '#settingsAsyncApiTitle',
      '#settingsAsyncApiDescription'
    ];
    settingsParams.forEach((p) => {
      document.querySelector(p).value = '';
    });
    document.querySelector('#settingsPanel').classList.remove('panel-wrap-out');
  };

  /**
   * Display the form to create or edit a producer component.
   *
   * @param {Producer} producer - Producer object
   */
  const displayProducer = (producer) => {
    document.querySelector('#deleteProducerForm').classList.add('hidden');
    document.querySelector('#producerPanel').classList.add('panel-wrap-out');

    document.querySelector('#producerIdField').value = '';
    document.querySelector('#producerNameField').value = '';
    document.querySelector('#producerRoutingKeyField').value = '';
    document.querySelector('#producerPublishTo').innerHTML = '';

    const exchanges = window.scene.getObjectsInScene('Exchange');
    refreshPublishToSelect(producer, exchanges);

    if (producer) {
      document.querySelector('#deleteProducerForm').classList.remove('hidden');
      document.querySelector('#producerIdField').value = producer.id;
      document.querySelector('#producerNameField').value = producer.name;
      document.querySelector('#producerRoutingKeyField').value =
        producer.routingKey;
      let exchangesDom = '';
      producer.exchanges.forEach((exchange) => {
        exchangesDom += `<div id="${exchange.id}" class="row">`;
        exchangesDom += `<input type="hidden" name="producerExchanges[]" value="${exchange.id}">`;
        exchangesDom += `<div class="flex-left">${exchange.name}</div>`;
        exchangesDom += `<div class="flex-right"><a href="#" data-id="${exchange.id}" class="exchangeDeleteLink">&times;</a></div>`;
        exchangesDom += '</div>';
      });
      document.querySelector('#producerPublishTo').innerHTML = exchangesDom;
      document.querySelectorAll('.exchangeDeleteLink').forEach((item) => {
        item.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.target.parentNode.parentNode.remove();
          refreshPublishToSelect(producer, exchanges);
        });
      });
    }
  };

  /**
   * Refreshs the `producerPublishToSelect` element.
   *
   * @param {Producer} producer - Producer object
   * @param {Exchange} exchange - Exchange object
   */
  const refreshPublishToSelect = (producer, exchanges) => {
    const selectSource = document.getElementById('producerPublishToSelect');
    selectSource.options.length = 0;
    selectSource.options[selectSource.options.length] = new Option('---', 0);
    Object.keys(exchanges).forEach((exchange) => {
      if (producer && producer.exchanges) {
        const presentExchanges = producer.exchanges.findIndex(
          (s) => s.id === exchanges[exchange].id
        );
        if (presentExchanges === -1) {
          selectSource.options[selectSource.options.length] = new Option(
            exchanges[exchange].name,
            exchanges[exchange].id
          );
        }
      } else {
        selectSource.options[selectSource.options.length] = new Option(
          exchanges[exchange].name,
          exchanges[exchange].id
        );
      }
    });
  };

  /**
   * Sends the form to create or edit a producer component.
   *
   * @param {object} e - Event object
   */
  const sendProducerForm = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const id = document.querySelector('#producerIdField').value;
    const name = document.querySelector('#producerNameField').value;
    const routingKey = document.querySelector('#producerRoutingKeyField').value;
    const publishTo = document.querySelector('#producerPublishToSelect').value;

    if (id) {
      const producer = window.scene.getIdInScene(id);

      const exchanges = document.getElementsByName('producerExchanges[]');
      const idsToKeep = [];
      exchanges.forEach((exchange) => {
        idsToKeep.push(exchange.value);
      });
      const restExchanges = producer.exchanges.filter(
        (s) => idsToKeep.indexOf(s.id) !== -1
      );
      const removeExchanges = producer.exchanges.filter(
        (s) => idsToKeep.indexOf(s.id) === -1
      );
      removeExchanges.forEach((rmExchange) => {
        const exchange = window.scene.getIdInScene(rmExchange.id);
        producer.removeExchange(exchange);
      });

      producer.name = name;
      producer.routingKey = routingKey;
      producer.exchanges = restExchanges;
      if (publishTo !== '0') {
        producer.addExchange(window.scene.getIdInScene(publishTo));
      }
    } else {
      const Producer1 = new Producer(200, 30, name, 0, routingKey);
      Producer1.addToScene(window.scene);
      if (publishTo !== '0') {
        Producer1.addExchange(window.scene.getIdInScene(publishTo));
      }
    }

    window.scene.renderOnce();

    document.querySelector('#producerIdField').value = '';
    document.querySelector('#producerNameField').value = '';
    document.querySelector('#producerRoutingKeyField').value = '';
    document.querySelector('#producerPanel').classList.remove('panel-wrap-out');
  };

  /**
   * Reset form values and remove CSS class from the producer panel.
   *
   * @param {object} e - Event object
   */
  const hideProducer = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const settingsParams = [
      '#producerIdField',
      '#producerNameField',
      '#producerRoutingKeyField'
    ];
    settingsParams.forEach((p) => {
      document.querySelector(p).value = '';
    });
    document.querySelector('#producerPanel').classList.remove('panel-wrap-out');
  };

  /**
   * Remove producer from the scene, render and remove CSS class from the producer panel.
   *
   * @param {object} e - Event object
   */
  const deleteProducerForm = (e) => {
    e.preventDefault();
    e.stopPropagation();
    window.scene.removeActor(
      window.scene.getIdInScene(document.querySelector('#producerIdField').value)
    );
    window.scene.renderOnce();
    document.querySelector('#producerPanel').classList.remove('panel-wrap-out');
  };

  /**
   * Display the form to create or edit consumer component.
   *
   * @param {Consumer} consumer - Consumer object
   */
  const displayConsumer = (consumer) => {
    document.querySelector('#deleteConsumerForm').classList.add('hidden');
    document.querySelector('#consumerPanel').classList.add('panel-wrap-out');

    document.querySelector('#consumerIdField').value = '';
    document.querySelector('#consumerNameField').value = '';
    document.querySelector('#consumerConsumesFrom').innerHTML = '';

    const queues = window.scene.getObjectsInScene('Queue');
    const selectSource = document.querySelector('#consumerConsumesFromSelect');
    selectSource.options.length = 0;
    selectSource.options[selectSource.options.length] = new Option('---', 0);
    Object.keys(queues).forEach((queue) => {
      if (consumer && consumer.queues) {
        const presentQueue = consumer.queues.findIndex(
          (s) => s.id === queues[queue].id
        );
        if (presentQueue === -1) {
          selectSource.options[selectSource.options.length] = new Option(
            queues[queue].name,
            queues[queue].id
          );
        }
      } else {
        selectSource.options[selectSource.options.length] = new Option(
          queues[queue].name,
          queues[queue].id
        );
      }
    });

    if (consumer) {
      document.querySelector('#deleteConsumerForm').classList.remove('hidden');
      document.querySelector('#consumerIdField').value = consumer.id;
      document.querySelector('#consumerNameField').value = consumer.name;

      const modes = document.getElementsByName('consumerMode');
      modes.forEach((val) => {
        if (consumer.mode === val.value) {
          // eslint-disable-next-line no-param-reassign
          val.checked = true;
        }
      });

      let queuesDom = '';
      consumer.queues.forEach((queue) => {
        queuesDom += `<div id="${queue.id}" class="row">`;
        queuesDom += `<input type="hidden" name="consumerQueues[]" value="${queue.id}">`;
        queuesDom += `<div class="flex-left">${queue.name}</div>`;
        queuesDom += `<div class="flex-right"><a href="#" data-id="${queue.id}" class="queueDeleteLink">&times;</a></div>`;
        queuesDom += '</div>';
      });
      document.querySelector('#consumerConsumesFrom').innerHTML = queuesDom;
      document.querySelectorAll('.queueDeleteLink').forEach((item) => {
        item.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          e.target.parentNode.parentNode.remove();
        });
      });
    }
  };

  /**
   * Reset form values and remove CSS class from the consumer panel.
   *
   * @param {object} e - Event object
   */
  const hideConsumer = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const settingsParams = ['#consumerIdField', '#consumerNameField'];
    settingsParams.forEach((p) => {
      document.querySelector(p).value = '';
    });
    document.querySelector('#consumerPanel').classList.remove('panel-wrap-out');
  };

  /**
   * Sends the form to create or edit a consumer component.
   * @param {object} e - Event object
   */
  const sendConsumerForm = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const id = document.querySelector('#consumerIdField').value;
    const name = document.querySelector('#consumerNameField').value;
    const modes = document.getElementsByName('consumerMode');
    const consumesFrom = document.querySelector(
      '#consumerConsumesFromSelect'
    ).value;

    let mode;
    modes.forEach((val) => {
      if (val.checked) {
        mode = val.value;
      }
    });

    if (id) {
      const consumer = window.scene.getIdInScene(id);

      const queues = document.getElementsByName('consumerQueues[]');
      const idsToKeep = [];
      queues.forEach((queue) => {
        idsToKeep.push(queue.value);
      });
      const restQueues = consumer.queues.filter(
        (s) => idsToKeep.indexOf(s.id) !== -1
      );
      const removeQueues = consumer.queues.filter(
        (s) => idsToKeep.indexOf(s.id) === -1
      );
      removeQueues.forEach((rmQueue) => {
        const actor = window.scene.getIdInScene(rmQueue.id);
        actor.removeConsumer(consumer);
      });

      consumer.name = name;
      consumer.mode = mode;
      consumer.queues = restQueues;

      if (consumesFrom !== '0') {
        consumer.addQueue(window.scene.getIdInScene(consumesFrom));
      }
    } else {
      const Consumer1 = new Consumer(800, 30, name, []);
      Consumer1.addToScene(window.scene);
      if (consumesFrom !== '0') {
        Consumer1.addQueue(window.scene.getIdInScene(consumesFrom));
      }
    }

    window.scene.renderOnce();

    document.querySelector('#consumerIdField').value = '';
    document.querySelector('#consumerNameField').value = '';
    document.querySelector('#consumerPanel').classList.remove('panel-wrap-out');
  };

  /**
   * Remove consumer from the scene, render and remove CSS class from the consumer panel.
   *
   * @param {object} e - Event object
   */
  const deleteConsumerForm = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const consumer = window.scene.getIdInScene(
      document.querySelector('#consumerIdField').value
    );
    consumer.queues.forEach((rmQueue) => {
      const actor = window.scene.getIdInScene(rmQueue.id);
      actor.removeConsumer(consumer);
    });
    window.scene.removeActor(consumer);
    window.scene.renderOnce();
    document.querySelector('#consumerPanel').classList.remove('panel-wrap-out');
  };

  /**
   * Display the form to create or edit exchange component.
   *
   * @param {Exchange} exchange - Exchange object
   */
  const displayExchange = (exchange) => {
    document.querySelector('#deleteExchangeForm').classList.add('hidden');
    document.querySelector('#exchangePanel').classList.add('panel-wrap-out');

    document.querySelector('#exchangeErr').innerHTML = '';
    document.querySelector('#exchangeIdField').value = '';
    document.querySelector('#exchangeNameField').value = '';
    document.querySelector('#exchangeTypeSelect').value = 'direct';
    if (exchange) {
      document.querySelector('#deleteExchangeForm').classList.remove('hidden');
      document.querySelector('#exchangeIdField').value = exchange.id;
      document.querySelector('#exchangeNameField').value = exchange.name;
      document.querySelector('#exchangeTypeSelect').value = exchange.type;
    }
  };

  /**
   * Sends the form to create or edit an exchange component.
   *
   * @param {object} e - Event object
   */
  const sendExchangeForm = (e) => {
    e.preventDefault();
    e.stopPropagation();

    const id = document.querySelector('#exchangeIdField').value;
    const name = document.querySelector('#exchangeNameField').value;
    const type = document.querySelector('#exchangeTypeSelect').value;
    let error = false;

    if (name === '') {
      error = 'Name is required.';
      document.querySelector('#exchangeErr').innerHTML = error;
    } else if (id) {
      const exchanges = window.scene.getObjectsInScene('Exchange');
      const exchangeIndex = exchanges.findIndex((e) => e.name === name);
      if (exchangeIndex === -1) {
        const exchange = window.scene.getIdInScene(id);
        exchange.name = name;
        exchange.type = type;
      } else {
        error = `Exchange with name '${name}' already exists.`;
        document.querySelector('#exchangeErr').innerHTML = error;
      }
    } else {
      const exchanges = window.scene.getObjectsInScene('Exchange');
      const exchangeIndex = exchanges.findIndex((e) => e.name === name);
      if (exchangeIndex === -1) {
        const Exchange1 = new Exchange(400, 30, name, type);
        Exchange1.addToScene(window.scene);
      } else {
        error = `Exchange with name '${name}' already exists.`;
        document.querySelector('#exchangeErr').innerHTML = error;
      }
    }

    window.scene.renderOnce();

    if (!error) {
      document.querySelector('#exchangeIdField').value = '';
      document.querySelector('#exchangeNameField').value = '';
      document.querySelector('#exchangeTypeSelect').value = 'direct';
      document.querySelector('#exchangePanel').classList.remove('panel-wrap-out');
    }
  };

  /**
   * Reset form values and remove CSS class from the exchange panel.
   *
   * @param {object} e - Event object
   */
  const hideExchange = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const settingsParams = ['#exchangeIdField', '#exchangeNameField'];
    settingsParams.forEach((p) => {
      document.querySelector(p).value = '';
    });
    document.querySelector('#exchangeTypeSelect').value = 'direct';
    document.querySelector('#exchangePanel').classList.remove('panel-wrap-out');
  };

  /**
   * Remove exchange from the scene, render and remove CSS class from the exchange panel.
   *
   * @param {object} e - Event object
   */
  const deleteExchangeForm = (e) => {
    e.preventDefault();
    e.stopPropagation();
    window.scene.removeActor(
      window.scene.getIdInScene(document.querySelector('#exchangeIdField').value)
    );
    window.scene.renderOnce();
    document.querySelector('#exchangePanel').classList.remove('panel-wrap-out');
  };

  /**
   * Display the form to create or edit queue component.
   *
   * @param {Queue} queue - Queue object
   */
  const displayQueue = (queue) => {
    document.querySelector('#deleteQueueForm').classList.add('hidden');
    document.querySelector('#queuePanel').classList.add('panel-wrap-out');

    document.querySelector('#queueErr').innerHTML = '';
    document.querySelector('#queueIdField').value = '';
    document.querySelector('#queueNameField').value = '';
    document.querySelector('#queueMsgTtlField').value = '';
    document.querySelector('#queueMaxLengthField').value = '';

    let dlx = { id: null };
    //let dlxrk = ''
    if (queue) {
      document.querySelector('#deleteQueueForm').classList.remove('hidden');
      document.querySelector('#queueIdField').value = queue.id;
      document.querySelector('#queueNameField').value = queue.name;
      document.querySelector('#queueMsgTtlField').value = queue.msgTtl;
      document.querySelector('#queueMaxLengthField').value = queue.maxLength;
      if (queue.dlx) {
        dlx = queue.dlx;
        //dlxrk = queue.dlxrk
        document.querySelector('#queueDlRoutingKey').value = queue.dlxrk;
      }
    }

    const exchanges = window.scene.getObjectsInScene('Exchange');
    const selectDlx = document.querySelector('#queueDlxSelect');
    selectDlx.options.length = 0;
    selectDlx.options[selectDlx.options.length] = new Option(
      'Dead Letter Exchange',
      0
    );
    Object.keys(exchanges).forEach((exchange) => {
      if (dlx.id === exchanges[exchange].id) {
        selectDlx.options[selectDlx.options.length] = new Option(
          exchanges[exchange].name,
          exchanges[exchange].id,
          false,
          true
        );
      } else {
        selectDlx.options[selectDlx.options.length] = new Option(
          exchanges[exchange].name,
          exchanges[exchange].id
        );
      }
    });
  };

  /**
   * Sends the form to create or edit an queue component.
   *
   * @param {object} e - Event object
   */
  const sendQueueForm = (e) => {
    e.preventDefault();
    e.stopPropagation();

    const id = document.querySelector('#queueIdField').value;
    const name = document.querySelector('#queueNameField').value;
    const msgTtl = document.querySelector('#queueMsgTtlField').value;
    const dlx = document.querySelector('#queueDlxSelect').value;
    const dlxrk = document.querySelector('#queueDlRoutingKey').value;
    const maxLength = document.querySelector('#queueMaxLengthField').value;
    let error = false;

    if (name === '') {
      error = 'Name is required.';
      document.querySelector('#queueErr').innerHTML = error;
    } else if (id) {
      const queue = window.scene.getIdInScene(id);
      queue.name = name;
      queue.msgTtl = msgTtl;
      queue.maxLength = maxLength;
      queue.dlx = window.scene.getIdInScene(dlx);
      queue.dlxrk = dlxrk;
    } else {
      const queues = window.scene.getObjectsInScene('Queue');
      const queueIndex = queues.findIndex((q) => q.name === name);
      if (queueIndex === -1) {
        const Queue1 = new Queue(650, 30, name);
        Queue1.addToScene(window.scene);
        Queue1.msgTtl = msgTtl;
        Queue1.dlx = window.scene.getIdInScene(dlx);
        Queue1.dlxrk = dlxrk;
      } else {
        error = `Queue with name '${name}' already exists.`;
        document.querySelector('#queueErr').innerHTML = error;
      }
    }

    window.scene.renderOnce();

    if (!error) {
      document.querySelector('#queueIdField').value = '';
      document.querySelector('#queueNameField').value = '';
      document.querySelector('#queueMsgTtlField').value = '';
      document.querySelector('#queueMaxLengthField').value = '';
      document.querySelector('#queuePanel').classList.remove('panel-wrap-out');
    }
  };

  /**
   * Reset form values and remove CSS class from the queue panel.
   *
   * @param {object} e - Event object
   */
  const hideQueue = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const settingsParams = [
      '#queueIdField',
      '#queueNameField',
      '#queueMsgTtlField',
      '#queueMaxLengthField'
    ];
    settingsParams.forEach((p) => {
      document.querySelector(p).value = '';
    });
    document.querySelector('#queuePanel').classList.remove('panel-wrap-out');
  };

  /**
   * Removes queue from the scene, render and remove CSS class from the queue panel.
   *
   * @param {object} e - Event object
   */
  const deleteQueueForm = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const actor = window.scene.getIdInScene(
      document.querySelector('#queueIdField').value
    );
    actor.consumers.forEach((consumer) => {
      consumer.removeQueue(actor);
    });
    if (actor && actor.bindings) {
      actor.bindings.forEach((binding) => {
        binding.source.removeBinding(binding);
        window.scene.removeActor(binding);
      });
    }
    window.scene.removeActor(actor);
    window.scene.renderOnce();
    document.querySelector('#queuePanel').classList.remove('panel-wrap-out');
  };

  /**
   * Display the form to create or edit binding component.
   *
   * @param {Binding} binding - Binding object
   */
  const displayBinding = (binding) => {
    document.querySelector('#deleteBindingForm').classList.add('hidden');
    document.querySelector('#bindingPanel').classList.add('panel-wrap-out');

    document.querySelector('#bindingIdField').value = '';
    document.querySelector('#bindingRoutingKeyField').value = '';

    let sourceId = null;
    let destinationId = null;
    if (binding) {
      document.querySelector('#deleteBindingForm').classList.remove('hidden');
      document.querySelector('#bindingIdField').value = binding.id;
      document.querySelector('#bindingRoutingKeyField').value = binding.routingKey;
      sourceId = binding.source.id;
      destinationId = binding.destination.id;
    }

    const exchanges = window.scene.getObjectsInScene('Exchange');
    const queues = window.scene.getObjectsInScene('Queue');

    const selectSource = document.getElementById('bindingSource');
    selectSource.options.length = 0;
    Object.keys(exchanges).forEach((exchange) => {
      if (sourceId === exchanges[exchange].id) {
        selectSource.options[selectSource.options.length] = new Option(
          exchanges[exchange].name,
          exchanges[exchange].id,
          false,
          true
        );
      } else {
        selectSource.options[selectSource.options.length] = new Option(
          exchanges[exchange].name,
          exchanges[exchange].id
        );
      }
    });
    const selectDestination = document.getElementById('bindingDestination');
    selectDestination.options.length = 0;
    Object.keys(queues).forEach((queue) => {
      if (destinationId === queues[queue].id) {
        selectDestination.options[selectDestination.options.length] = new Option(
          queues[queue].name,
          queues[queue].id,
          false,
          true
        );
      } else {
        selectDestination.options[selectDestination.options.length] = new Option(
          queues[queue].name,
          queues[queue].id
        );
      }
    });
  };

  /**
   * Sends the form to create or edit an binding component.
   *
   * @param {object} e - Event object
   */
  const sendBindingForm = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const id = document.querySelector('#bindingIdField').value;
    const routingKey = document.querySelector('#bindingRoutingKeyField').value;

    const selectSource = document.getElementById('bindingSource').value;
    const selectDestination = document.getElementById('bindingDestination').value;

    const ex = window.scene.actors.find((exc) => exc.id === selectSource);
    const qu = window.scene.actors.find((q) => q.id === selectDestination);

    if (id) {
      const binding = window.scene.getIdInScene(id);
      binding.routingKey = routingKey;

      binding.source = ex;
      binding.destination = qu;
      binding.setCoords();
    } else {
      // let e = window.scene.actors.find(e => e.id === selectSource);
      // let q = window.scene.actors.find(q => q.id === selectDestination);
      const Binding1 = new Binding(ex, qu, routingKey);
      Binding1.addToScene(window.scene);
    }

    window.scene.renderOnce();

    document.querySelector('#bindingIdField').value = '';
    document.querySelector('#bindingRoutingKeyField').value = '';
    document.getElementById('bindingSource').value = '';
    document.getElementById('bindingDestination').value = '';
    document.querySelector('#bindingPanel').classList.remove('panel-wrap-out');
  };

  /**
   * Reset form values and remove CSS class from the binding panel.
   *
   * @param {object} e - Event object
   */
  const hideBinding = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const settingsParams = [
      '#bindingIdField',
      '#bindingRoutingKeyField',
      '#bindingSource',
      '#bindingDestination'
    ];
    settingsParams.forEach((p) => {
      document.querySelector(p).value = '';
    });
    document.querySelector('#bindingPanel').classList.remove('panel-wrap-out');
  };

  /**
   * @param {object} e - Event object
   */
  const deleteBindingForm = (e) => {
    e.preventDefault();
    e.stopPropagation();
    const actor = window.scene.getIdInScene(
      document.querySelector('#bindingIdField').value
    );
    actor.source.removeBinding(actor);
    window.scene.removeActor(actor);
    window.scene.renderOnce();
    document.querySelector('#bindingPanel').classList.remove('panel-wrap-out');
  };

  /**
   * Export topology as curl statements.
   *
   * @param {object} e - Event object
   */
  const exportCurl = (e) => {
    e.preventDefault();
    e.stopPropagation();
    displayForm('imexportForm');
    document.querySelector('#importBtn').classList.add('hidden');
    let generatedString = '';
    const brokerSettings = getSettings();
    const { management } = brokerSettings;
    const { username } = brokerSettings;
    const { password } = brokerSettings;
    const { vhost } = brokerSettings;
    const exchanges = window.scene.getObjectsInScene('Exchange');
    exchanges.forEach((val) => {
      const name = encodeURIComponent(val.name);
      generatedString += `curl -u ${username}:${password} -i -H "content-type:application/json" -XPUT ${management}/exchanges/${vhost}/${name} -d '{"type": "${val.type}", "auto_delete": false, "durable": true, "internal": false, "arguments": {}}'\n\n`;
    });
    const queues = window.scene.getObjectsInScene('Queue');
    queues.forEach((val) => {
      const name = encodeURIComponent(val.name);
      const args = {};
      if (val.dlx) {
        args['x-dead-letter-exchange'] = val.dlx.name;
        args['x-dead-letter-routing-key'] = val.dlxrk;
      }
      if (val.msgTtl) {
        args['x-message-ttl'] = val.msgTtl;
      }
      if (val.maxLength) {
        args['x-max-length'] = val.maxLength;
      }
      generatedString += `curl -u ${username}:${password} -i -H "content-type:application/json" -XPUT ${management}/queues/${vhost}/${name} -d '{"auto_delete": false, "durable": true, "arguments": ${JSON.stringify(
      args
    )}}'\n\n`;
    });
    const bindings = window.scene.getObjectsInScene('Binding');
    bindings.forEach((val) => {
      const exchangeIndex = exchanges.findIndex((e) => e.id === val.source.id);
      const queueIndex = queues.findIndex((q) => q.id === val.destination.id);
      if (exchangeIndex !== -1 && queueIndex !== -1) {
        const exchange = exchanges[exchangeIndex];
        const queue = queues[queueIndex];
        generatedString += `curl -u ${username}:${password} -i -H "content-type:application/json" -XPUT ${management}/bindings/e/${encodeURIComponent(
        exchange.name
      )}/q/${encodeURIComponent(queue.name)} -d '{"routing_key": ${
        val.routingKey
      }, "arguments": {}}'\n\n`;
      }
    });
    document.querySelector('#ImExport').value = generatedString;
    document.querySelector('#imexportPanel').classList.add('panel-wrap-out');
  };

  /**
   * Export topology as rabbitmqadmin statements.
   *
   * @param {object} e - Event object
   */
  const exportRabbitmqadmin = (e) => {
    e.preventDefault();
    e.stopPropagation();
    displayForm('imexportForm');
    document.querySelector('#importBtn').classList.add('hidden');
    let generatedString = '';
    const brokerSettings = getSettings();
    const { management } = brokerSettings;
    const { username } = brokerSettings;
    const { password } = brokerSettings;
    const url = new URL(management);
    let { vhost } = brokerSettings;
    if (vhost === '%2f') {
      vhost = '/';
    }
    const exchanges = window.scene.getObjectsInScene('Exchange');
    exchanges.forEach((val) => {
      generatedString += `rabbitmqadmin -H ${url.hostname} -u ${username} -p ${password} -V ${vhost} declare exchange name="${val.name}" type="${val.type}" durable=true\n\n`;
    });
    const queues = window.scene.getObjectsInScene('Queue');
    queues.forEach((val) => {
      const args = {};
      if (val.dlx) {
        args['x-dead-letter-exchange'] = val.dlx.name;
        args['x-dead-letter-routing-key'] = val.dlxrk;
      }
      if (val.msgTtl) {
        args['x-message-ttl'] = val.msgTtl;
      }
      if (val.maxLength) {
        args['x-max-length'] = val.maxLength;
      }
      generatedString += `rabbitmqadmin -H ${url.hostname} -u ${username} -p ${password} -V ${vhost} declare queue name="${val.name}" durable=true`;
      if (Object.keys(args).length !== 0) {
        generatedString += ` arguments='${JSON.stringify(args)}'`;
      }
      generatedString += '\n\n';
    });
    const bindings = window.scene.getObjectsInScene('Binding');
    bindings.forEach((val) => {
      const exchangeIndex = exchanges.findIndex((e) => e.id === val.source.id);
      const queueIndex = queues.findIndex((q) => q.id === val.destination.id);
      if (exchangeIndex !== -1 && queueIndex !== -1) {
        const exchange = exchanges[exchangeIndex];
        const queue = queues[queueIndex];
        generatedString += `rabbitmqadmin -H ${url.hostname} -u ${username} -p ${password} -V ${vhost} declare binding source="${exchange.name}" destination_type="queue" destination="${queue.name}" routing_key="${val.routingKey}"\n\n`;
      }
    });
    document.querySelector('#ImExport').value = generatedString;
    document.querySelector('#imexportPanel').classList.add('panel-wrap-out');
  };

  /**
   * Export topology as Terraform.
   *
   * @param {object} e - Event object
   */
  const exportTerraform = (e) => {
    e.preventDefault();
    e.stopPropagation();
    displayForm('imexportForm');
    document.querySelector('#importBtn').classList.add('hidden');
    let generatedString = '';
    const brokerSettings = getSettings();
    const { management } = brokerSettings;
    const { username } = brokerSettings;
    const { password } = brokerSettings;
    const url = new URL(management);
    let { vhost } = brokerSettings;
    if (vhost === '%2f') {
      vhost = '/';
    }
    generatedString += `terraform {
    required_providers {
      rabbitmq = {
        source = "cyrilgdn/rabbitmq"
        version = "1.8.0"
      }
    }
  }
  provider "rabbitmq" {
    endpoint = "${url.origin}"
    username = "${username}"
    password = "${password}"
  }
  resource "rabbitmq_vhost" "vhost" {
    name = "${vhost}"
  }
  `;
    const exchanges = window.scene.getObjectsInScene('Exchange');
    exchanges.forEach((val) => {
      const name = val.name.replace(/ /g, '-');
      generatedString += `resource "rabbitmq_exchange" "${name}" {
    name  = "${val.name}"
    vhost = "\${rabbitmq_vhost.vhost.name}"
    settings {
      type        = "${val.type}"
      durable     = true
      auto_delete = false
    }
  }
  `;
    });
    const queues = window.scene.getObjectsInScene('Queue');
    queues.forEach((val) => {
      const name = val.name.replace(/ /g, '-');
      if (val.dlx || val.msgTtl || val.maxlength) {
        generatedString += `variable "${name}args" {
      default = <<EOF
      {
  `;
        const extra = [];
        if (val.dlx) {
          extra.push(`"x-dead-letter-exchange": "${val.dlx.name}"`);
          extra.push(`"x-dead-letter-routing-key": "${val.dlxrk}"`);
        }
        if (val.msgTtl) {
          extra.push(`"x-message-ttl": ${val.msgTtl}`);
        }
        if (val.maxLength) {
          extra.push(`"x-max-length": ${val.maxLength}`);
        }
        generatedString += `        ${extra.join(',\n        ')}`;
        generatedString += `
      }
      EOF
  }
  `;
      }
      generatedString += `resource "rabbitmq_queue" "${name}" {
    name  = "${val.name}"
    vhost = "\${rabbitmq_vhost.vhost.name}"
      
    settings {
      durable     = true
      auto_delete = false`;
      if (val.dlx || val.msgTtl || val.maxlength) {
        generatedString += `
      arguments_json = "\${var.${name}args}"`;
      }
      generatedString += `
    }
  }
  `;
    });

    const bindings = window.scene.getObjectsInScene('Binding');
    bindings.forEach((val) => {
      const srcName = val.source.name.replace(/ /g, '-');
      const destName = val.destination.name.replace(/ /g, '-');
      generatedString += `resource "rabbitmq_binding" "${srcName}${destName}" {
    source           = "\${rabbitmq_exchange.${srcName}.name}"
    vhost            = "\${rabbitmq_vhost.vhost.name}"
    destination      = "\${rabbitmq_queue.${destName}.name}"
    destination_type = "queue"
    routing_key      = "${val.routingKey}"
  }
  `;
    });

    document.querySelector('#ImExport').value = generatedString;
    document.querySelector('#importBtn').classList.add('hidden');
    document.querySelector('#imexportPanel').classList.add('panel-wrap-out');
  };

  /**
   * Export topology as AsyncApi.
   *
   * @param {object} e - Event object
   */
  const exportAsyncApi = (e) => {
    e.preventDefault();
    e.stopPropagation();
    displayForm('imexportForm');
    document.querySelector('#importBtn').classList.add('hidden');
    let generatedString = '';
    const brokerSettings = getSettings();
    const { host } = brokerSettings;
    const { title, description } = brokerSettings.asyncapi;
    let { vhost } = brokerSettings;
    if (vhost === '%2f') {
      vhost = '/';
    }
    const exchanges = window.scene.getObjectsInScene('Exchange');
    const queues = window.scene.getObjectsInScene('Queue');

    generatedString += `asyncapi: 3.0.0
info:
  title: ${title}
  description: ${description}
  termsOfService: https://asyncapi.org/terms/
  contact:
    name: API Support
    url: https://www.asyncapi.org/support
    email: support@asyncapi.org
  license:
    name: Apache 2.0
    url: https://www.apache.org/licenses/LICENSE-2.0.htm
  version: 0.1.0
servers:
  production:
    host: ${host}
    protocol: amqps
    protocolVersion: 0.9.1
    description: Production broker.
    tags:
      - name: "env:production"
        description: "This environment is the live environment available for final users"
channels:
`;  
    exchanges.forEach((val) => {
      if (val.type === 'topic') {
        val.bindings.forEach((v) => {
          if (v.routingKey !== '#') {
            generatedString += `  ${val.name.replaceAll(' ', '_')}/${v.routingKey}:
    address: '${v.routingKey}'
    messages:
      event:
        $ref: '#/components/messages/Event'
    bindings:
      amqp:
        is: routingKey
        exchange:
          name: ${v.source.name}
          type: 'topic'
          durable: true
          autoDelete: false
          vhost: ${vhost}
`;
          }
        });
      } else {
        generatedString += `  ${val.name.replaceAll(' ', '_')}:
    messages:
      event:
        $ref: '#/components/messages/Event'
    bindings:
      amqp:
        is: routingKey
        exchange:
          name: ${val.name}
          type: '${val.type}'
          durable: true
          autoDelete: false
          vhost: ${vhost}
`;
      }
    });

    queues.forEach((val) => {
      generatedString += `  ${val.name.replaceAll(' ', '_')}:
    messages:
      event:
        $ref: '#/components/messages/Event'
    bindings:
      amqp:
        is: queue
        queue:
          name: ${val.name}
          durable: true
          exclusive: true
          autoDelete: false
`;
    });
    
    generatedString += `operations:`;
    exchanges.forEach((val) => {
      console.log(val);
      //val.bindings.forEach((v) => {
      generatedString += `
  send${val.name}:
    channel:
      $ref: '#/channels/${val.name.replaceAll(' ', '_')}'
    action: send`;
      //})
    });

    queues.forEach((val) => {
      generatedString += `
  receive${val.name.replaceAll(' ', '_')}:
    channel:
      $ref: '#/channels/${val.name.replaceAll(' ', '_')}'
    action: receive`;
    });  

    // remove two to start again
    //generatedString = generatedString.slice(0, -2)
    generatedString += `  
components:
  messages:
    Event:
      name: EventName
      title: Event Title
      summary: Summary of the event.
      description: Event description
      contentType: application/json
      tags:
        - name: message
        - name: example
      headers:
        type: object
        properties:
          correlationId:
            description: Correlation ID set by application
            type: string
          applicationInstanceId:
            description: Unique identifier for a given instance of the publishing application
            type: string
      payload:
        type: object
        additionalProperties: false
        properties:
          created:
            type: string
            description: The date and time a message was sent.
            format: datetime
          name:
            type: string
            description: The name of the message was sent.
          value:
            type: string
            description: The value of the message was sent.`;

    document.querySelector('#ImExport').value = generatedString;
    document.querySelector('#imexportPanel').classList.add('panel-wrap-out');
  };

  const Examples = {
    direct: {
      description:
        'Direct exchange sends message to the queue whose matches the routing key.',
      producers: [
        {
          x: 200,
          y: 130,
          name: 'Producer',
          publishes: [0],
          routingKey: 'Queue'
        }
      ],
      consumers: [
        {
          x: 800,
          y: 130,
          name: 'Consumer',
          consumes: [0],
          mode: 'ack'
        }
      ],
      exchanges: [
        {
          x: 400,
          y: 150,
          name: 'Exchange',
          type: 'direct'
        }
      ],
      queues: [{ x: 650, y: 150, name: 'Queue' }],
      bindings: [{ exchange: 0, queue: 0, routingKey: '' }]
    },
    fanout: {
      description:
        'Fanout exchange broadcasts all the messages to all bind queues, it ignores the routing key.',
      producers: [
        {
          x: 200,
          y: 130,
          name: 'Producer',
          publishes: [0]
        }
      ],
      consumers: [
        {
          x: 800,
          y: 50,
          name: 'Consumer 1',
          consumes: [0],
          mode: 'ack'
        },
        {
          x: 800,
          y: 150,
          name: 'Consumer 2',
          consumes: [1],
          mode: 'ack'
        },
        {
          x: 800,
          y: 250,
          name: 'Consumer 3',
          consumes: [2],
          mode: 'ack'
        }
      ],
      exchanges: [
        {
          x: 400,
          y: 170,
          name: 'Exchange',
          type: 'fanout'
        }
      ],
      queues: [
        { x: 650, y: 80, name: 'Queue 1' },
        { x: 650, y: 170, name: 'Queue 2' },
        { x: 650, y: 260, name: 'Queue 3' }
      ],
      bindings: [
        { exchange: 0, queue: 0, routingKey: '' },
        { exchange: 0, queue: 1, routingKey: '' },
        { exchange: 0, queue: 2, routingKey: '' }
      ]
    },
    topic: {
      description:
        'Topic exchange sends messages by routing key to the matching queue.',
      producers: [
        {
          x: 200,
          y: 130,
          name: 'Producer 1',
          publishes: [0]
        },
        {
          x: 200,
          y: 200,
          name: 'Producer 2',
          publishes: [0]
        }
      ],
      consumers: [
        {
          x: 800,
          y: 80,
          name: 'Consumer 1',
          consumes: [0],
          mode: 'ack'
        },
        {
          x: 800,
          y: 170,
          name: 'Consumer 2',
          consumes: [1],
          mode: 'ack'
        },
        {
          x: 800,
          y: 260,
          name: 'Consumer 3',
          consumes: [2],
          mode: 'ack'
        }
      ],
      exchanges: [
        {
          x: 400,
          y: 170,
          name: 'Exchange',
          type: 'topic'
        }
      ],
      queues: [
        { x: 650, y: 80, name: 'Queue 1' },
        { x: 650, y: 170, name: 'Queue 2' },
        { x: 650, y: 260, name: 'Queue 3' }
      ],
      bindings: [
        { exchange: 0, queue: 0, routingKey: 'x.x.x' },
        { exchange: 0, queue: 1, routingKey: '#' },
        { exchange: 0, queue: 2, routingKey: 'x.y.z' }
      ]
    },
    'queue-ttl': {
      description:
        'Time to live for queues, messages which are staying longer are removed.',
      producers: [
        {
          x: 200,
          y: 100,
          name: 'Producer',
          publishes: [0],
          routingKey: 'Queue'
        }
      ],
      consumers: [],
      exchanges: [
        {
          x: 400,
          y: 130,
          name: 'Exchange',
          type: 'direct'
        }
      ],
      queues: [
        {
          x: 650,
          y: 130,
          name: 'Queue',
          ttl: 3000
        }
      ],
      bindings: [{ exchange: 0, queue: 0, routingKey: '' }]
    },
    'queue-max-length': {
      description:
        'Queues can have a maximum length of messages before they get dead lettered.',
      producers: [
        {
          x: 200,
          y: 100,
          name: 'Producer',
          publishes: [0],
          routingKey: 'Queue 1'
        }
      ],
      consumers: [
        {
          x: 800,
          y: 80,
          name: 'Consumer 1',
          consumes: [1],
          mode: 'reject'
        },
        {
          x: 800,
          y: 170,
          name: 'Consumer 2',
          consumes: [1],
          mode: 'ack'
        }
      ],
      exchanges: [
        {
          x: 400,
          y: 80,
          name: 'Exchange 1',
          type: 'direct'
        },
        {
          x: 400,
          y: 170,
          name: 'Exchange 2',
          type: 'direct'
        }
      ],
      queues: [
        {
          x: 650,
          y: 80,
          name: 'Queue 1',
          dlx: 1,
          dlxrk: 'Queue 2',
          maxLength: 5
        },
        { x: 650, y: 170, name: 'Queue 2' }
      ],
      bindings: [
        { exchange: 0, queue: 0, routingKey: '' },
        { exchange: 1, queue: 1, routingKey: '' }
      ]
    },
    dlx: {
      description:
        'Dead letter exchanges are used to get dead lettered messages republished.',
      producers: [
        {
          x: 200,
          y: 100,
          name: 'Producer',
          publishes: [0],
          routingKey: 'Queue 1'
        }
      ],
      consumers: [
        {
          x: 800,
          y: 100,
          name: 'Consumer 1',
          consumes: [0],
          mode: 'reject'
        },
        {
          x: 800,
          y: 170,
          name: 'Consumer 2',
          consumes: [1],
          mode: 'ack'
        }
      ],
      exchanges: [
        {
          x: 400,
          y: 100,
          name: 'Exchange 1',
          type: 'direct'
        },
        {
          x: 400,
          y: 200,
          name: 'Exchange 2',
          type: 'direct'
        }
      ],
      queues: [
        {
          x: 650,
          y: 100,
          name: 'Queue 1',
          dlx: 1,
          dlxrk: 'Queue 2'
        },
        { x: 650, y: 200, name: 'Queue 2' }
      ],
      bindings: [
        { exchange: 0, queue: 0, routingKey: '' },
        { exchange: 1, queue: 1, routingKey: '' }
      ]
    },
    retry: {
      description:
        'Simple time based retry mechanism with a queue to park and republish messages.',
      producers: [
        {
          x: 200,
          y: 100,
          name: 'Producer',
          publishes: [0],
          routingKey: 'Queue 1'
        }
      ],
      consumers: [
        {
          x: 800,
          y: 100,
          name: 'Consumer 1',
          consumes: [0],
          mode: 'reject'
        }
      ],
      exchanges: [
        {
          x: 400,
          y: 100,
          name: 'Exchange 1',
          type: 'direct'
        },
        {
          x: 650,
          y: 200,
          name: 'Exchange 2',
          type: 'direct'
        }
      ],
      queues: [
        {
          x: 650,
          y: 100,
          name: 'Queue 1',
          dlx: 1,
          dlxrk: 'Queue 2'
        },
        {
          x: 400,
          y: 300,
          name: 'Queue 2',
          dlx: 0,
          dlxrk: 'Queue 1',
          ttl: 3000
        }
      ],
      bindings: [
        { exchange: 0, queue: 0, routingKey: '' },
        { exchange: 1, queue: 1, routingKey: '' }
      ]
    }
  };

  // --- Producer ---
  document
    .querySelector('#sendProducerForm')
    .addEventListener('click', sendProducerForm);

  document
    .querySelector('#cancelProducerForm')
    .addEventListener('click', hideProducer);

  document
    .querySelector('#deleteProducerForm')
    .addEventListener('click', deleteProducerForm);

  // --- Consumer ---
  document
    .querySelector('#sendConsumerForm')
    .addEventListener('click', sendConsumerForm);

  document
    .querySelector('#cancelConsumerForm')
    .addEventListener('click', hideConsumer);

  document
    .querySelector('#deleteConsumerForm')
    .addEventListener('click', deleteConsumerForm);

  // --- Exchange ---
  document
    .querySelector('#sendExchangeForm')
    .addEventListener('click', sendExchangeForm);

  document
    .querySelector('#cancelExchangeForm')
    .addEventListener('click', hideExchange);

  document
    .querySelector('#deleteExchangeForm')
    .addEventListener('click', deleteExchangeForm);

  // --- Queue ---
  document
    .querySelector('#sendQueueForm')
    .addEventListener('click', sendQueueForm);

  document.querySelector('#cancelQueueForm').addEventListener('click', hideQueue);

  document
    .querySelector('#deleteQueueForm')
    .addEventListener('click', deleteQueueForm);

  // --- Binding ---
  document
    .querySelector('#sendBindingForm')
    .addEventListener('click', sendBindingForm);

  document
    .querySelector('#cancelBindingForm')
    .addEventListener('click', hideBinding);

  document
    .querySelector('#deleteBindingForm')
    .addEventListener('click', deleteBindingForm);

  // --- Settings ---
  document
    .querySelector('#settingsTabs')
    .addEventListener('click', changeSettingsTab);

  document
    .querySelector('#sendSettingsForm')
    .addEventListener('click', sendSettingsForm);

  document
    .querySelector('#cancelSettingsForm')
    .addEventListener('click', hideSettings);

  const brokerDefaultSettings = {
    host: 'localhost',
    port: 5672,
    management: `http://localhost:15672/api`,
    vhost: '%2f',
    username: 'guest',
    password: 'guest',
    asyncapi: {
      title: 'RabbitMQ',
      description: 'Broker description.'
    }
  };
  if (getSettings() === null) {
    setSettings(brokerDefaultSettings);
  }

  const config = {
    description: 'RMQ Topology helps to simulate and visualize the message flow.',
    producers: [],
    consumers: [],
    exchanges: [],
    queues: [],
    bindings: []
  };

  document.querySelector('#docLink').href = `${window.location.href}doc`;

  const canvas = document.querySelector('#canvas');
  canvas.width = window.innerWidth;
  canvas.height = 450;
  const curCtx = canvas.getContext('2d');

  createTopology(curCtx, config);

  document.querySelector('#exampleTopology').addEventListener('change', (e) => {
    e.preventDefault();
    e.stopPropagation();
    displayForm('');
    let restart = false;
    if (window.timer.running) {
      window.timer.stop();
      window.scene.purge();
      window.scene.renderOnce();
      restart = true;
    }
    if (e.target.value !== 'Examples') {
      createTopology(curCtx, Examples[e.target.value.toLowerCase()]);
      if (restart) {
        window.timer.start();
      }
    } else {
      window.scene.purge();
      window.scene.description = '';
      window.scene.renderOnce();
    }
  });

  document.querySelector('#newComponent').addEventListener('change', (e) => {
    e.preventDefault();
    e.stopPropagation();
    displayForm(e.target.value);
    switch (e.target.value) {
      case 'Producer':
        displayProducer();
        break
      case 'Consumer':
        displayConsumer();
        break
      case 'Exchange':
        displayExchange();
        break
      case 'Queue':
        displayQueue();
        break
      case 'Binding':
        displayBinding();
        break
    }
    e.target.selectedIndex = 0;
  });

  /**
   * Current mouse position inside of a cirle.
   * @param {object} val - can be Exchange or Queue object
   * @param {number} mx - x position of the mouse
   * @param {number} my - y position of the mouse
   * @returns {object}
   */
  const findCircle = (val, mx, my) => {
    let found;
    if (val.constructor.name === 'Exchange' || val.constructor.name === 'Queue') {
      const d = Math.floor(Math.sqrt((val.x - mx) ** 2 + (val.y - my) ** 2));
      if (d <= val.radius) {
        found = val;
      }
    }
    return found
  };

  /**
   * Current mouse position inside of a square.
   * @param {object} val - can be Producer or Consumer object
   * @param {number} mx - x position of the mouse
   * @param {number} my - y position of the mouse
   * @returns {object}
   */
  const findSquare = (val, mx, my) => {
    let found;
    if (
      val.constructor.name === 'Producer' ||
      val.constructor.name === 'Consumer'
    ) {
      if (
        mx >= val.x &&
        mx <= val.x + val.width &&
        my >= val.y &&
        my <= val.y + val.height
      ) {
        found = val;
      }
    }
    return found
  };

  /**
   * Current mouse position over a line.
   * @param {Binding} val - Binding object
   * @param {number} mx - x position of the mouse
   * @param {number} my - y position of the mouse
   * @returns {object}
   */
  const findLine = (val, mx, my) => {
    let found;
    const line = {
      x0: val.x1,
      x1: val.x2,
      y0: val.y1,
      y1: val.y2
    };

    let x1;
    let x2;
    if (line.x0 > line.x1) {
      x1 = line.x1;
      x2 = line.x0;
    } else {
      x1 = line.x0;
      x2 = line.x1;
    }
    if (mx > x1 && mx < x2) {
      // determine how close the mouse must be to the line
      // for the mouse to be inside the line
      const tolerance = 3;
      const linepoint = linepointNearestMouse(line, mx, my);
      const dx = mx - linepoint.x;
      const dy = my - linepoint.y;
      const distance = Math.abs(Math.sqrt(dx * dx + dy * dy));
      if (distance < tolerance) {
        found = val;
      }
    }
    return found
  };

  /**
   * Find the actor in the scene from the current mouse position.
   * @param {object} e - Event object
   * @param {*} line
   * @returns {object} - undefined or the found actor in scene
   */
  const findPosition = (e, line = false) => {
    const mx = e.clientX - e.target.offsetLeft;
    const my = e.clientY - e.target.offsetTop;
    let obj;
    window.scene.actors.forEach((val) => {
      const foundProducerConsumer = findSquare(val, mx, my);
      if (foundProducerConsumer) {
        obj = foundProducerConsumer;
      }
      const foundExchangeQueue = findCircle(val, mx, my);
      if (foundExchangeQueue) {
        obj = foundExchangeQueue;
      }
      if (line) {
        const foundLine = findLine(val, mx, my);
        if (foundLine) {
          obj = foundLine;
        }
      }
    });
    return obj
  };

  canvas.addEventListener('mousedown', (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (!window.timer.running) {
      const ele = findPosition(e);
      if (ele) {
        ele.dragged = true;
        ele.hover = false;
      }
    }
  });

  canvas.addEventListener('mouseup', (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (!window.timer.running) {
      window.scene.actors.map((obj) => {
        obj.dragged = false;
        return true
      });
      window.scene.renderOnce();
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    e.preventDefault();
    e.stopPropagation();
    document.body.style.cursor = 'default';
    if (!window.timer.running) {
      const mx = e.clientX - e.target.offsetLeft;
      const my = e.clientY - e.target.offsetTop;

      const draggedActor = window.scene.actors.filter((a) => a.dragged === true);
      if (draggedActor.length > 0) {
        const actor = draggedActor[0];
        document.body.style.cursor = 'pointer';
        if (actor.constructor.name === 'Producer') {
          actor.x = mx - actor.width / 2;
          actor.y = my - actor.height / 2;
        } else if (actor.constructor.name === 'Consumer') {
          actor.x = mx - actor.width / 2;
          actor.y = my - actor.height / 2;
        } else {
          actor.x = mx;
          actor.y = my;
        }
        if (actor.binding) {
          if (actor.binding.source === actor) {
            actor.bindings.forEach((binding) => {
              binding.x1 = mx;
              binding.y1 = my;
            });
          }
          if (actor.binding.destination === actor) {
            actor.bindings.forEach((binding) => {
              binding.x2 = mx;
              binding.y2 = my;
            });
          }
        }
      } else {
        window.scene.actors.forEach((val) => {
          val.hover = false;
          const foundProducerConsumer = findSquare(val, mx, my);
          if (foundProducerConsumer) {
            document.body.style.cursor = 'pointer';
            val.hover = true;
          }
          const foundExchangeQueue = findCircle(val, mx, my);
          if (foundExchangeQueue) {
            document.body.style.cursor = 'pointer';
            val.hover = true;
          }

          if (val.constructor.name === 'Binding') {
            const foundLine = findLine(val, mx, my);
            if (foundLine) {
              document.body.style.cursor = 'pointer';
              val.hover = true;
            }
          }
        });
      }
      window.scene.renderOnce();
    }
  });

  canvas.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    const ele = findPosition(e, true);
    if (ele && ele.constructor) {
      switch (ele.constructor.name) {
        case 'Producer':
          displayForm(ele.constructor.name);
          displayProducer(ele);
          break
        case 'Exchange':
          displayForm(ele.constructor.name);
          displayExchange(ele);
          break
        case 'Queue':
          displayForm(ele.constructor.name);
          displayQueue(ele);
          break
        case 'Binding':
          displayForm(ele.constructor.name);
          displayBinding(ele);
          break
        case 'Consumer':
          displayForm(ele.constructor.name);
          displayConsumer(ele);
          break
        default:
          console.log(ele.constructor.name);
      }
    }
  });

  const animateBtn = document.querySelector('#animate');
  animateBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    if (animateBtn.innerHTML === '<i class="fas fa-play"></i> Start') {
      window.timer.start();
      animateBtn.innerHTML = '<i class="fas fa-stop"></i> Stop';
    } else {
      window.timer.stop();
      animateBtn.innerHTML = '<i class="fas fa-play"></i> Start';
    }
  });

  const settingsBtn = document.querySelector('#settings');
  settingsBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    displayForm('settingsForm');
    displaySettings();
  });

  const exportBtn = document.querySelector('#export');
  exportBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    document.querySelector('#importBtn').classList.remove('hidden');
    const exports = {
      description: '',
      producers: [],
      consumers: [],
      exchanges: [],
      queues: [],
      bindings: []
    };
    const exchanges = window.scene.getObjectsInScene('Exchange');
    exchanges.forEach((val) => {
      exports.exchanges.push({
        x: val.x,
        y: val.y,
        name: val.name,
        type: val.type
      });
    });
    const queues = window.scene.getObjectsInScene('Queue');
    queues.forEach((val) => {
      const q = {
        x: val.x,
        y: val.y,
        name: val.name,
        ttl: val.ttl,
        maxLength: val.maxLength
      };
      if (val.dlx) {
        const exchangeIndex = exchanges.findIndex((e) => e.id === val.dlx.id);
        q.dlx = exchangeIndex;
      }
      exports.queues.push(q);
    });
    const bindings = window.scene.getObjectsInScene('Binding');
    bindings.forEach((val) => {
      const exchangeIndex = exchanges.findIndex((e) => e.id === val.source.id);
      const queueIndex = queues.findIndex((q) => q.id === val.destination.id);
      if (exchangeIndex !== -1 && queueIndex !== -1) {
        exports.bindings.push({
          exchange: exchangeIndex,
          queue: queueIndex,
          routingKey: val.routingKey
        });
      }
    });
    const consumers = window.scene.getObjectsInScene('Consumer');
    consumers.forEach((val) => {
      const consumes = [];
      val.queues.forEach((queue) => {
        const queueIndex = queues.findIndex((q) => q.id === queue.id);
        consumes.push(queueIndex);
      });
      exports.consumers.push({
        x: val.x,
        y: val.y,
        name: val.name,
        consumes,
        mode: val.mode
      });
    });
    const producers = window.scene.getObjectsInScene('Producer');
    producers.forEach((val) => {
      exports.producers.push({
        x: val.x,
        y: val.y,
        name: val.name,
        publishes: val.publishes,
        routingKey: val.routingKey
      });
    });

    document.querySelector('#ImExport').value = JSON.stringify(exports);
    document.querySelector('#imexportPanel').classList.add('panel-wrap-out');
  });

  document.querySelector('#copyBtn').addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    document.querySelector('#ImExport').select();
    document.execCommand('copy');
  });

  const importBtn = document.querySelector('#importBtn');
  importBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    const importStr = document.querySelector('#ImExport').value;
    try {
      const jsonStr = JSON.parse(importStr);
      createTopology(curCtx, jsonStr);
      document.querySelector('#imexportPanel').classList.remove('panel-wrap-out');
    } catch (e) {
      document.querySelector('#imexportErr').innerHTML = 'Parse error';
    }
  });

  const cancelBtn = document.querySelector('#cancelBtn');
  cancelBtn.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    document.querySelector('#imexportPanel').classList.remove('panel-wrap-out');
  });

  const generateCurlBtn = document.querySelector('#generateCurl');
  generateCurlBtn.addEventListener('click', exportCurl);

  const generateRmqBtn = document.querySelector('#generateRabbitmqadmin');
  generateRmqBtn.addEventListener('click', exportRabbitmqadmin);

  const generateTfBtn = document.querySelector('#generateTerraform');
  generateTfBtn.addEventListener('click', exportTerraform);

  const generateAsyncApiBtn = document.querySelector('#generateAsyncApi');
  generateAsyncApiBtn.addEventListener('click', exportAsyncApi);

})();
//# sourceMappingURL=script.min.js.map
